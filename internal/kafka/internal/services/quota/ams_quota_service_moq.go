// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package quota

import (
	"github.com/bf2fc6cc711aee1a0c2a/kas-fleet-manager/internal/kafka/internal/api/dbapi"
	"github.com/bf2fc6cc711aee1a0c2a/kas-fleet-manager/internal/kafka/internal/config"
	"github.com/bf2fc6cc711aee1a0c2a/kas-fleet-manager/internal/kafka/internal/kafkas/types"
	"github.com/bf2fc6cc711aee1a0c2a/kas-fleet-manager/pkg/errors"
	amsv1 "github.com/openshift-online/ocm-sdk-go/accountsmgmt/v1"
	"sync"
)

// Ensure, that AMSQuotaServiceMock does implement AMSQuotaService.
// If this is not the case, regenerate this file with moq.
var _ AMSQuotaService = &AMSQuotaServiceMock{}

// AMSQuotaServiceMock is a mock implementation of AMSQuotaService.
//
//	func TestSomethingThatUsesAMSQuotaService(t *testing.T) {
//
//		// make and configure a mocked AMSQuotaService
//		mockedAMSQuotaService := &AMSQuotaServiceMock{
//			CheckIfQuotaIsDefinedForInstanceTypeFunc: func(username string, externalID string, instanceTypeID types.KafkaInstanceType, kafkaBillingModel config.KafkaBillingModel) (bool, *errors.ServiceError) {
//				panic("mock out the CheckIfQuotaIsDefinedForInstanceType method")
//			},
//			DeleteQuotaFunc: func(subscriptionId string) *errors.ServiceError {
//				panic("mock out the DeleteQuota method")
//			},
//			DeleteQuotaForBillingModelFunc: func(subscriptionId string, kafkaBillingModel config.KafkaBillingModel) *errors.ServiceError {
//				panic("mock out the DeleteQuotaForBillingModel method")
//			},
//			GetSubscriptionByIDFunc: func(subscriptionID string) (*amsv1.Subscription, bool, *errors.ServiceError) {
//				panic("mock out the GetSubscriptionByID method")
//			},
//			IsQuotaEntitlementActiveFunc: func(kafka *dbapi.KafkaRequest) (bool, error) {
//				panic("mock out the IsQuotaEntitlementActive method")
//			},
//			ReserveQuotaFunc: func(kafka *dbapi.KafkaRequest) (string, *errors.ServiceError) {
//				panic("mock out the ReserveQuota method")
//			},
//			ReserveQuotaIfNotAlreadyReservedFunc: func(kafka *dbapi.KafkaRequest) (string, *errors.ServiceError) {
//				panic("mock out the ReserveQuotaIfNotAlreadyReserved method")
//			},
//			ValidateBillingAccountFunc: func(organisationId string, instanceType types.KafkaInstanceType, billingModelID string, billingCloudAccountId string, marketplace *string) *errors.ServiceError {
//				panic("mock out the ValidateBillingAccount method")
//			},
//		}
//
//		// use mockedAMSQuotaService in code that requires AMSQuotaService
//		// and then make assertions.
//
//	}
type AMSQuotaServiceMock struct {
	// CheckIfQuotaIsDefinedForInstanceTypeFunc mocks the CheckIfQuotaIsDefinedForInstanceType method.
	CheckIfQuotaIsDefinedForInstanceTypeFunc func(username string, externalID string, instanceTypeID types.KafkaInstanceType, kafkaBillingModel config.KafkaBillingModel) (bool, *errors.ServiceError)

	// DeleteQuotaFunc mocks the DeleteQuota method.
	DeleteQuotaFunc func(subscriptionId string) *errors.ServiceError

	// DeleteQuotaForBillingModelFunc mocks the DeleteQuotaForBillingModel method.
	DeleteQuotaForBillingModelFunc func(subscriptionId string, kafkaBillingModel config.KafkaBillingModel) *errors.ServiceError

	// GetSubscriptionByIDFunc mocks the GetSubscriptionByID method.
	GetSubscriptionByIDFunc func(subscriptionID string) (*amsv1.Subscription, bool, *errors.ServiceError)

	// IsQuotaEntitlementActiveFunc mocks the IsQuotaEntitlementActive method.
	IsQuotaEntitlementActiveFunc func(kafka *dbapi.KafkaRequest) (bool, error)

	// ReserveQuotaFunc mocks the ReserveQuota method.
	ReserveQuotaFunc func(kafka *dbapi.KafkaRequest) (string, *errors.ServiceError)

	// ReserveQuotaIfNotAlreadyReservedFunc mocks the ReserveQuotaIfNotAlreadyReserved method.
	ReserveQuotaIfNotAlreadyReservedFunc func(kafka *dbapi.KafkaRequest) (string, *errors.ServiceError)

	// ValidateBillingAccountFunc mocks the ValidateBillingAccount method.
	ValidateBillingAccountFunc func(organisationId string, instanceType types.KafkaInstanceType, billingModelID string, billingCloudAccountId string, marketplace *string) *errors.ServiceError

	// calls tracks calls to the methods.
	calls struct {
		// CheckIfQuotaIsDefinedForInstanceType holds details about calls to the CheckIfQuotaIsDefinedForInstanceType method.
		CheckIfQuotaIsDefinedForInstanceType []struct {
			// Username is the username argument value.
			Username string
			// ExternalID is the externalID argument value.
			ExternalID string
			// InstanceTypeID is the instanceTypeID argument value.
			InstanceTypeID types.KafkaInstanceType
			// KafkaBillingModel is the kafkaBillingModel argument value.
			KafkaBillingModel config.KafkaBillingModel
		}
		// DeleteQuota holds details about calls to the DeleteQuota method.
		DeleteQuota []struct {
			// SubscriptionId is the subscriptionId argument value.
			SubscriptionId string
		}
		// DeleteQuotaForBillingModel holds details about calls to the DeleteQuotaForBillingModel method.
		DeleteQuotaForBillingModel []struct {
			// SubscriptionId is the subscriptionId argument value.
			SubscriptionId string
			// KafkaBillingModel is the kafkaBillingModel argument value.
			KafkaBillingModel config.KafkaBillingModel
		}
		// GetSubscriptionByID holds details about calls to the GetSubscriptionByID method.
		GetSubscriptionByID []struct {
			// SubscriptionID is the subscriptionID argument value.
			SubscriptionID string
		}
		// IsQuotaEntitlementActive holds details about calls to the IsQuotaEntitlementActive method.
		IsQuotaEntitlementActive []struct {
			// Kafka is the kafka argument value.
			Kafka *dbapi.KafkaRequest
		}
		// ReserveQuota holds details about calls to the ReserveQuota method.
		ReserveQuota []struct {
			// Kafka is the kafka argument value.
			Kafka *dbapi.KafkaRequest
		}
		// ReserveQuotaIfNotAlreadyReserved holds details about calls to the ReserveQuotaIfNotAlreadyReserved method.
		ReserveQuotaIfNotAlreadyReserved []struct {
			// Kafka is the kafka argument value.
			Kafka *dbapi.KafkaRequest
		}
		// ValidateBillingAccount holds details about calls to the ValidateBillingAccount method.
		ValidateBillingAccount []struct {
			// OrganisationId is the organisationId argument value.
			OrganisationId string
			// InstanceType is the instanceType argument value.
			InstanceType types.KafkaInstanceType
			// BillingModelID is the billingModelID argument value.
			BillingModelID string
			// BillingCloudAccountId is the billingCloudAccountId argument value.
			BillingCloudAccountId string
			// Marketplace is the marketplace argument value.
			Marketplace *string
		}
	}
	lockCheckIfQuotaIsDefinedForInstanceType sync.RWMutex
	lockDeleteQuota                          sync.RWMutex
	lockDeleteQuotaForBillingModel           sync.RWMutex
	lockGetSubscriptionByID                  sync.RWMutex
	lockIsQuotaEntitlementActive             sync.RWMutex
	lockReserveQuota                         sync.RWMutex
	lockReserveQuotaIfNotAlreadyReserved     sync.RWMutex
	lockValidateBillingAccount               sync.RWMutex
}

// CheckIfQuotaIsDefinedForInstanceType calls CheckIfQuotaIsDefinedForInstanceTypeFunc.
func (mock *AMSQuotaServiceMock) CheckIfQuotaIsDefinedForInstanceType(username string, externalID string, instanceTypeID types.KafkaInstanceType, kafkaBillingModel config.KafkaBillingModel) (bool, *errors.ServiceError) {
	if mock.CheckIfQuotaIsDefinedForInstanceTypeFunc == nil {
		panic("AMSQuotaServiceMock.CheckIfQuotaIsDefinedForInstanceTypeFunc: method is nil but AMSQuotaService.CheckIfQuotaIsDefinedForInstanceType was just called")
	}
	callInfo := struct {
		Username          string
		ExternalID        string
		InstanceTypeID    types.KafkaInstanceType
		KafkaBillingModel config.KafkaBillingModel
	}{
		Username:          username,
		ExternalID:        externalID,
		InstanceTypeID:    instanceTypeID,
		KafkaBillingModel: kafkaBillingModel,
	}
	mock.lockCheckIfQuotaIsDefinedForInstanceType.Lock()
	mock.calls.CheckIfQuotaIsDefinedForInstanceType = append(mock.calls.CheckIfQuotaIsDefinedForInstanceType, callInfo)
	mock.lockCheckIfQuotaIsDefinedForInstanceType.Unlock()
	return mock.CheckIfQuotaIsDefinedForInstanceTypeFunc(username, externalID, instanceTypeID, kafkaBillingModel)
}

// CheckIfQuotaIsDefinedForInstanceTypeCalls gets all the calls that were made to CheckIfQuotaIsDefinedForInstanceType.
// Check the length with:
//
//	len(mockedAMSQuotaService.CheckIfQuotaIsDefinedForInstanceTypeCalls())
func (mock *AMSQuotaServiceMock) CheckIfQuotaIsDefinedForInstanceTypeCalls() []struct {
	Username          string
	ExternalID        string
	InstanceTypeID    types.KafkaInstanceType
	KafkaBillingModel config.KafkaBillingModel
} {
	var calls []struct {
		Username          string
		ExternalID        string
		InstanceTypeID    types.KafkaInstanceType
		KafkaBillingModel config.KafkaBillingModel
	}
	mock.lockCheckIfQuotaIsDefinedForInstanceType.RLock()
	calls = mock.calls.CheckIfQuotaIsDefinedForInstanceType
	mock.lockCheckIfQuotaIsDefinedForInstanceType.RUnlock()
	return calls
}

// DeleteQuota calls DeleteQuotaFunc.
func (mock *AMSQuotaServiceMock) DeleteQuota(subscriptionId string) *errors.ServiceError {
	if mock.DeleteQuotaFunc == nil {
		panic("AMSQuotaServiceMock.DeleteQuotaFunc: method is nil but AMSQuotaService.DeleteQuota was just called")
	}
	callInfo := struct {
		SubscriptionId string
	}{
		SubscriptionId: subscriptionId,
	}
	mock.lockDeleteQuota.Lock()
	mock.calls.DeleteQuota = append(mock.calls.DeleteQuota, callInfo)
	mock.lockDeleteQuota.Unlock()
	return mock.DeleteQuotaFunc(subscriptionId)
}

// DeleteQuotaCalls gets all the calls that were made to DeleteQuota.
// Check the length with:
//
//	len(mockedAMSQuotaService.DeleteQuotaCalls())
func (mock *AMSQuotaServiceMock) DeleteQuotaCalls() []struct {
	SubscriptionId string
} {
	var calls []struct {
		SubscriptionId string
	}
	mock.lockDeleteQuota.RLock()
	calls = mock.calls.DeleteQuota
	mock.lockDeleteQuota.RUnlock()
	return calls
}

// DeleteQuotaForBillingModel calls DeleteQuotaForBillingModelFunc.
func (mock *AMSQuotaServiceMock) DeleteQuotaForBillingModel(subscriptionId string, kafkaBillingModel config.KafkaBillingModel) *errors.ServiceError {
	if mock.DeleteQuotaForBillingModelFunc == nil {
		panic("AMSQuotaServiceMock.DeleteQuotaForBillingModelFunc: method is nil but AMSQuotaService.DeleteQuotaForBillingModel was just called")
	}
	callInfo := struct {
		SubscriptionId    string
		KafkaBillingModel config.KafkaBillingModel
	}{
		SubscriptionId:    subscriptionId,
		KafkaBillingModel: kafkaBillingModel,
	}
	mock.lockDeleteQuotaForBillingModel.Lock()
	mock.calls.DeleteQuotaForBillingModel = append(mock.calls.DeleteQuotaForBillingModel, callInfo)
	mock.lockDeleteQuotaForBillingModel.Unlock()
	return mock.DeleteQuotaForBillingModelFunc(subscriptionId, kafkaBillingModel)
}

// DeleteQuotaForBillingModelCalls gets all the calls that were made to DeleteQuotaForBillingModel.
// Check the length with:
//
//	len(mockedAMSQuotaService.DeleteQuotaForBillingModelCalls())
func (mock *AMSQuotaServiceMock) DeleteQuotaForBillingModelCalls() []struct {
	SubscriptionId    string
	KafkaBillingModel config.KafkaBillingModel
} {
	var calls []struct {
		SubscriptionId    string
		KafkaBillingModel config.KafkaBillingModel
	}
	mock.lockDeleteQuotaForBillingModel.RLock()
	calls = mock.calls.DeleteQuotaForBillingModel
	mock.lockDeleteQuotaForBillingModel.RUnlock()
	return calls
}

// GetSubscriptionByID calls GetSubscriptionByIDFunc.
func (mock *AMSQuotaServiceMock) GetSubscriptionByID(subscriptionID string) (*amsv1.Subscription, bool, *errors.ServiceError) {
	if mock.GetSubscriptionByIDFunc == nil {
		panic("AMSQuotaServiceMock.GetSubscriptionByIDFunc: method is nil but AMSQuotaService.GetSubscriptionByID was just called")
	}
	callInfo := struct {
		SubscriptionID string
	}{
		SubscriptionID: subscriptionID,
	}
	mock.lockGetSubscriptionByID.Lock()
	mock.calls.GetSubscriptionByID = append(mock.calls.GetSubscriptionByID, callInfo)
	mock.lockGetSubscriptionByID.Unlock()
	return mock.GetSubscriptionByIDFunc(subscriptionID)
}

// GetSubscriptionByIDCalls gets all the calls that were made to GetSubscriptionByID.
// Check the length with:
//
//	len(mockedAMSQuotaService.GetSubscriptionByIDCalls())
func (mock *AMSQuotaServiceMock) GetSubscriptionByIDCalls() []struct {
	SubscriptionID string
} {
	var calls []struct {
		SubscriptionID string
	}
	mock.lockGetSubscriptionByID.RLock()
	calls = mock.calls.GetSubscriptionByID
	mock.lockGetSubscriptionByID.RUnlock()
	return calls
}

// IsQuotaEntitlementActive calls IsQuotaEntitlementActiveFunc.
func (mock *AMSQuotaServiceMock) IsQuotaEntitlementActive(kafka *dbapi.KafkaRequest) (bool, error) {
	if mock.IsQuotaEntitlementActiveFunc == nil {
		panic("AMSQuotaServiceMock.IsQuotaEntitlementActiveFunc: method is nil but AMSQuotaService.IsQuotaEntitlementActive was just called")
	}
	callInfo := struct {
		Kafka *dbapi.KafkaRequest
	}{
		Kafka: kafka,
	}
	mock.lockIsQuotaEntitlementActive.Lock()
	mock.calls.IsQuotaEntitlementActive = append(mock.calls.IsQuotaEntitlementActive, callInfo)
	mock.lockIsQuotaEntitlementActive.Unlock()
	return mock.IsQuotaEntitlementActiveFunc(kafka)
}

// IsQuotaEntitlementActiveCalls gets all the calls that were made to IsQuotaEntitlementActive.
// Check the length with:
//
//	len(mockedAMSQuotaService.IsQuotaEntitlementActiveCalls())
func (mock *AMSQuotaServiceMock) IsQuotaEntitlementActiveCalls() []struct {
	Kafka *dbapi.KafkaRequest
} {
	var calls []struct {
		Kafka *dbapi.KafkaRequest
	}
	mock.lockIsQuotaEntitlementActive.RLock()
	calls = mock.calls.IsQuotaEntitlementActive
	mock.lockIsQuotaEntitlementActive.RUnlock()
	return calls
}

// ReserveQuota calls ReserveQuotaFunc.
func (mock *AMSQuotaServiceMock) ReserveQuota(kafka *dbapi.KafkaRequest) (string, *errors.ServiceError) {
	if mock.ReserveQuotaFunc == nil {
		panic("AMSQuotaServiceMock.ReserveQuotaFunc: method is nil but AMSQuotaService.ReserveQuota was just called")
	}
	callInfo := struct {
		Kafka *dbapi.KafkaRequest
	}{
		Kafka: kafka,
	}
	mock.lockReserveQuota.Lock()
	mock.calls.ReserveQuota = append(mock.calls.ReserveQuota, callInfo)
	mock.lockReserveQuota.Unlock()
	return mock.ReserveQuotaFunc(kafka)
}

// ReserveQuotaCalls gets all the calls that were made to ReserveQuota.
// Check the length with:
//
//	len(mockedAMSQuotaService.ReserveQuotaCalls())
func (mock *AMSQuotaServiceMock) ReserveQuotaCalls() []struct {
	Kafka *dbapi.KafkaRequest
} {
	var calls []struct {
		Kafka *dbapi.KafkaRequest
	}
	mock.lockReserveQuota.RLock()
	calls = mock.calls.ReserveQuota
	mock.lockReserveQuota.RUnlock()
	return calls
}

// ReserveQuotaIfNotAlreadyReserved calls ReserveQuotaIfNotAlreadyReservedFunc.
func (mock *AMSQuotaServiceMock) ReserveQuotaIfNotAlreadyReserved(kafka *dbapi.KafkaRequest) (string, *errors.ServiceError) {
	if mock.ReserveQuotaIfNotAlreadyReservedFunc == nil {
		panic("AMSQuotaServiceMock.ReserveQuotaIfNotAlreadyReservedFunc: method is nil but AMSQuotaService.ReserveQuotaIfNotAlreadyReserved was just called")
	}
	callInfo := struct {
		Kafka *dbapi.KafkaRequest
	}{
		Kafka: kafka,
	}
	mock.lockReserveQuotaIfNotAlreadyReserved.Lock()
	mock.calls.ReserveQuotaIfNotAlreadyReserved = append(mock.calls.ReserveQuotaIfNotAlreadyReserved, callInfo)
	mock.lockReserveQuotaIfNotAlreadyReserved.Unlock()
	return mock.ReserveQuotaIfNotAlreadyReservedFunc(kafka)
}

// ReserveQuotaIfNotAlreadyReservedCalls gets all the calls that were made to ReserveQuotaIfNotAlreadyReserved.
// Check the length with:
//
//	len(mockedAMSQuotaService.ReserveQuotaIfNotAlreadyReservedCalls())
func (mock *AMSQuotaServiceMock) ReserveQuotaIfNotAlreadyReservedCalls() []struct {
	Kafka *dbapi.KafkaRequest
} {
	var calls []struct {
		Kafka *dbapi.KafkaRequest
	}
	mock.lockReserveQuotaIfNotAlreadyReserved.RLock()
	calls = mock.calls.ReserveQuotaIfNotAlreadyReserved
	mock.lockReserveQuotaIfNotAlreadyReserved.RUnlock()
	return calls
}

// ValidateBillingAccount calls ValidateBillingAccountFunc.
func (mock *AMSQuotaServiceMock) ValidateBillingAccount(organisationId string, instanceType types.KafkaInstanceType, billingModelID string, billingCloudAccountId string, marketplace *string) *errors.ServiceError {
	if mock.ValidateBillingAccountFunc == nil {
		panic("AMSQuotaServiceMock.ValidateBillingAccountFunc: method is nil but AMSQuotaService.ValidateBillingAccount was just called")
	}
	callInfo := struct {
		OrganisationId        string
		InstanceType          types.KafkaInstanceType
		BillingModelID        string
		BillingCloudAccountId string
		Marketplace           *string
	}{
		OrganisationId:        organisationId,
		InstanceType:          instanceType,
		BillingModelID:        billingModelID,
		BillingCloudAccountId: billingCloudAccountId,
		Marketplace:           marketplace,
	}
	mock.lockValidateBillingAccount.Lock()
	mock.calls.ValidateBillingAccount = append(mock.calls.ValidateBillingAccount, callInfo)
	mock.lockValidateBillingAccount.Unlock()
	return mock.ValidateBillingAccountFunc(organisationId, instanceType, billingModelID, billingCloudAccountId, marketplace)
}

// ValidateBillingAccountCalls gets all the calls that were made to ValidateBillingAccount.
// Check the length with:
//
//	len(mockedAMSQuotaService.ValidateBillingAccountCalls())
func (mock *AMSQuotaServiceMock) ValidateBillingAccountCalls() []struct {
	OrganisationId        string
	InstanceType          types.KafkaInstanceType
	BillingModelID        string
	BillingCloudAccountId string
	Marketplace           *string
} {
	var calls []struct {
		OrganisationId        string
		InstanceType          types.KafkaInstanceType
		BillingModelID        string
		BillingCloudAccountId string
		Marketplace           *string
	}
	mock.lockValidateBillingAccount.RLock()
	calls = mock.calls.ValidateBillingAccount
	mock.lockValidateBillingAccount.RUnlock()
	return calls
}
